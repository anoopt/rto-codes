/**
 * Shared search utilities for RTO data.
 *
 * Provides punctuation-normalized matching and well-known
 * alternate name resolution (Belgaum→Belagavi, Bombay→Mumbai, etc.).
 *
 * Alternate names are loaded from data/alternate-names.json, which is
 * generated by scripts/generate-alternate-names.ts using Google Gemini.
 */

import alternateNamesData from '@/data/alternate-names.json';

/**
 * Flattened lookup: normalized alternate → normalized official names (and vice versa).
 * Built once from the JSON data at module load time.
 */
const ALTERNATE_LOOKUP: Record<string, string[]> = {};

for (const [official, alternates] of Object.entries(
    alternateNamesData as Record<string, string[]>,
)) {
    const normOfficial = official.toLowerCase();

    // alt → official
    for (const alt of alternates) {
        const normAlt = alt.toLowerCase();
        if (!ALTERNATE_LOOKUP[normAlt]) ALTERNATE_LOOKUP[normAlt] = [];
        if (!ALTERNATE_LOOKUP[normAlt].includes(normOfficial)) {
            ALTERNATE_LOOKUP[normAlt].push(normOfficial);
        }
    }

    // official → alts
    if (!ALTERNATE_LOOKUP[normOfficial]) ALTERNATE_LOOKUP[normOfficial] = [];
    for (const alt of alternates) {
        const normAlt = alt.toLowerCase();
        if (!ALTERNATE_LOOKUP[normOfficial].includes(normAlt)) {
            ALTERNATE_LOOKUP[normOfficial].push(normAlt);
        }
    }
}

/**
 * Strip punctuation and collapse whitespace for normalized comparison.
 * "H.S.R. Layout" → "hsr layout", "K.R. Puram" → "kr puram"
 */
export function normalize(text: string): string {
    return text.toLowerCase().replace(/[.\-_'/]/g, '').replace(/\s+/g, ' ').trim();
}

/**
 * Get search terms to try: the original query plus any known alternate names.
 * All returned terms are already normalized.
 */
export function getSearchTerms(query: string): string[] {
    const normalizedQuery = normalize(query);
    const terms = [normalizedQuery];

    // Check each word in the query against alternate names
    const words = normalizedQuery.split(' ');
    for (const word of words) {
        const alts = ALTERNATE_LOOKUP[word];
        if (alts) {
            for (const alt of alts) {
                terms.push(normalizedQuery.replace(word, alt));
            }
        }
    }

    // Also check full query as a whole
    const fullAlts = ALTERNATE_LOOKUP[normalizedQuery];
    if (fullAlts) {
        terms.push(...fullAlts);
    }

    return [...new Set(terms)];
}

/**
 * Check if any of the search terms match the target text (normalized).
 */
export function matchesNormalized(target: string, searchTerms: string[]): boolean {
    const normalizedTarget = normalize(target);
    return searchTerms.some((term) => normalizedTarget.includes(term));
}
