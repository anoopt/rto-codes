name: Scheduled RTO Population

on:
  # Run daily at 2 AM UTC
  schedule:
    - cron: "0 2 * * *"

  # Allow manual trigger with optional parameters
  workflow_dispatch:
    inputs:
      state:
        description: "State to process (leave empty for auto-rotation)"
        required: false
        type: string
      limit:
        description: "Number of RTOs to generate (default: 5, use 2-5 for testing)"
        required: false
        type: number
        default: 5
      force:
        description: "Force processing even if already complete"
        required: false
        type: boolean
        default: false

# Prevent concurrent runs to avoid conflicts
concurrency:
  group: rto-population
  cancel-in-progress: false

jobs:
  populate-rtos:
    name: Generate RTO Data
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Restore state rotation cache
        id: cache-restore
        uses: actions/cache/restore@v4
        with:
          path: .github-cache/state-rotation.json
          key: state-rotation-${{ github.run_id }}
          restore-keys: |
            state-rotation-

      - name: Determine target state
        id: determine-state
        run: |
          # Manual trigger takes precedence
          if [ -n "${{ inputs.state }}" ]; then
            echo "state=${{ inputs.state }}" >> $GITHUB_OUTPUT
            echo "üìå Manual trigger - processing state: ${{ inputs.state }}"
            exit 0
          fi

          # Load state rotation data
          if [ -f .github-cache/state-rotation.json ]; then
            LAST_STATE=$(jq -r '.lastProcessedState // ""' .github-cache/state-rotation.json)
            echo "Last processed: $LAST_STATE"
          else
            mkdir -p .github-cache
            LAST_STATE=""
          fi

          # Get all incomplete states
          STATES=$(find data -name "config.json" -type f | while read config; do
            IS_COMPLETE=$(jq -r '.isComplete' "$config")
            TOTAL_RTOS=$(jq -r '.totalRTOs' "$config")
            STATE_DIR=$(dirname "$config" | xargs basename)
            
            # Skip if complete or totalRTOs is 0 (not researched yet)
            if [ "$IS_COMPLETE" != "true" ] && [ "$TOTAL_RTOS" != "0" ]; then
              echo "$STATE_DIR"
            fi
          done | sort)

          if [ -z "$STATES" ]; then
            echo "‚úÖ All states complete or need RTO count verification!"
            echo "   Run: bun scripts/verify-total-rtos.ts"
            echo "state=NONE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if last processed state is still incomplete - if so, continue with it
          if [ -n "$LAST_STATE" ]; then
            for state in $STATES; do
              if [ "$state" = "$LAST_STATE" ]; then
                echo "state=$LAST_STATE" >> $GITHUB_OUTPUT
                echo "üîÑ Continuing with incomplete state: $LAST_STATE"
                exit 0
              fi
            done
            echo "‚úÖ $LAST_STATE is now complete, moving to next state"
          fi

          # Last state is complete (or no last state), find the next incomplete state
          FOUND_LAST=false
          for state in $STATES; do
            # If we found the last state previously, pick this one as next
            if [ "$FOUND_LAST" = "true" ]; then
              echo "state=$state" >> $GITHUB_OUTPUT
              echo "üîÑ Next state in rotation: $state"
              exit 0
            fi
            
            if [ "$state" = "$LAST_STATE" ]; then
              FOUND_LAST=true
            fi
          done

          # If we're here, start from beginning (wrap around or first run)
          FIRST_STATE=$(echo "$STATES" | head -n1)
          echo "state=$FIRST_STATE" >> $GITHUB_OUTPUT
          echo "üîÑ Starting new rotation cycle: $FIRST_STATE"

      - name: Check if state needs verification
        if: steps.determine-state.outputs.state != 'NONE'
        id: check-verification
        run: |
          STATE="${{ steps.determine-state.outputs.state }}"

          if [ ! -d "data/$STATE" ]; then
            echo "‚ùå State directory not found: $STATE"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if totalRTOs is set and validCodes exists
          TOTAL_RTOS=$(jq -r '.totalRTOs' "data/$STATE/config.json")
          HAS_VALID_CODES=$(jq 'has("validCodes") and (.validCodes | length > 0)' "data/$STATE/config.json")

          if [ "$TOTAL_RTOS" = "0" ] || [ "$HAS_VALID_CODES" = "false" ]; then
            echo "needs_verification=true" >> $GITHUB_OUTPUT
            echo "üîç State needs verification (totalRTOs=$TOTAL_RTOS, hasValidCodes=$HAS_VALID_CODES)"
          else
            echo "needs_verification=false" >> $GITHUB_OUTPUT
          fi

      - name: Auto-verify state RTO codes
        if: steps.determine-state.outputs.state != 'NONE' && steps.check-verification.outputs.needs_verification == 'true'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          STATE="${{ steps.determine-state.outputs.state }}"

          echo "üîç Auto-verifying RTO codes for $STATE..."

          if bun scripts/verify-total-rtos.ts --state="$STATE"; then
            echo "‚úÖ Verification complete"
            
            # Commit the updated config
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "github-actions[bot]"
            git add "data/$STATE/config.json"
            git commit -m "chore: auto-verify totalRTOs and validCodes for $STATE" || echo "No changes to commit"
            git push
          else
            echo "‚ùå Verification failed for $STATE"
            exit 1
          fi

      - name: Check if state needs processing
        if: steps.determine-state.outputs.state != 'NONE'
        id: check-state
        run: |
          STATE="${{ steps.determine-state.outputs.state }}"

          # Re-check config (may have been updated by verification)
          IS_COMPLETE=$(jq -r '.isComplete' "data/$STATE/config.json")
          TOTAL_RTOS=$(jq -r '.totalRTOs' "data/$STATE/config.json")

          # Count existing RTOs
          EXISTING_COUNT=$(find "data/$STATE" -name "*.json" -type f ! -name "config.json" ! -name "index.json" | wc -l)

          echo "State: $STATE"
          echo "Total RTOs expected: $TOTAL_RTOS"
          echo "Existing RTOs: $EXISTING_COUNT"
          echo "Is complete: $IS_COMPLETE"

          # Skip if already complete (unless force flag)
          if [ "$IS_COMPLETE" = "true" ] && [ "${{ inputs.force }}" != "true" ]; then
            echo "‚è≠Ô∏è State already marked complete"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # This should not happen after auto-verification, but check anyway
          if [ "$TOTAL_RTOS" = "0" ]; then
            echo "‚ùå totalRTOs still 0 after verification - something went wrong"
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "skip=false" >> $GITHUB_OUTPUT
          echo "existing=$EXISTING_COUNT" >> $GITHUB_OUTPUT
          echo "total=$TOTAL_RTOS" >> $GITHUB_OUTPUT

      - name: Generate RTO data
        if: steps.determine-state.outputs.state != 'NONE' && steps.check-state.outputs.skip != 'true'
        id: generate
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          STATE="${{ steps.determine-state.outputs.state }}"
          LIMIT="${{ inputs.limit || 5 }}"
          EXISTING="${{ steps.check-state.outputs.existing }}"
          TOTAL="${{ steps.check-state.outputs.total }}"

          # Find the starting point by locating the first missing code.
          # Using EXISTING+1 assumes sequential completion which breaks when
          # there are gaps (e.g., BR-18 missing while BR-19+ exist).
          HAS_VALID_CODES=$(jq 'has("validCodes") and (.validCodes | length > 0)' "data/$STATE/config.json")

          if [ "$HAS_VALID_CODES" = "true" ]; then
            # Find 1-based position of first missing code in validCodes
            START=0
            POSITION=0
            while IFS= read -r code; do
              POSITION=$((POSITION + 1))
              file="data/$STATE/$(echo "$code" | tr '[:upper:]' '[:lower:]').json"
              if [ ! -f "$file" ]; then
                START=$POSITION
                echo "üìç First missing code: $code (position $POSITION in validCodes)"
                break
              fi
            done < <(jq -r '.validCodes[]' "data/$STATE/config.json")

            # All codes have files - nothing to generate
            if [ "$START" = "0" ]; then
              echo "‚úÖ All validCodes have files on disk"
              echo "success=true" >> $GITHUB_OUTPUT
              echo "generated=0" >> $GITHUB_OUTPUT
              echo "new_total=$EXISTING" >> $GITHUB_OUTPUT
              exit 0
            fi
          else
            # Fallback for states without validCodes (sequential assumption)
            START=$((EXISTING + 1))
          fi

          END=$((START + LIMIT - 1))

          # Don't exceed total
          if [ $END -gt $TOTAL ]; then
            END=$TOTAL
          fi

          echo "üìù Generating RTOs $START to $END for $STATE"

          # Run populate script with retry logic
          # --skip-existing ensures codes that already have files in the range are skipped
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
            if [ $RETRY_COUNT -gt 0 ]; then
              echo "‚ö†Ô∏è Retry attempt $RETRY_COUNT/$MAX_RETRIES"
              sleep 5
            fi
            
            # Use --search for Google Search grounding to ensure accurate RTO data
            # Use --skip-existing to avoid re-processing codes that already have files
            if bun scripts/populate-rto-data.ts "$STATE" $START $END --search --skip-existing; then
              SUCCESS=true
              echo "‚úÖ Successfully generated RTOs"
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ùå Generation failed, attempt $RETRY_COUNT/$MAX_RETRIES"
            fi
          done

          if [ "$SUCCESS" = "false" ]; then
            echo "‚ùå Failed after $MAX_RETRIES attempts"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Count new files
          NEW_COUNT=$(find "data/$STATE" -name "*.json" -type f ! -name "config.json" ! -name "index.json" | wc -l)
          GENERATED=$((NEW_COUNT - EXISTING))

          echo "success=true" >> $GITHUB_OUTPUT
          echo "generated=$GENERATED" >> $GITHUB_OUTPUT
          echo "new_total=$NEW_COUNT" >> $GITHUB_OUTPUT

      - name: Commit and push to main
        if: steps.determine-state.outputs.state != 'NONE' && steps.check-state.outputs.skip != 'true' && steps.generate.outputs.success == 'true'
        id: commit
        run: |
          STATE="${{ steps.determine-state.outputs.state }}"
          GENERATED="${{ steps.generate.outputs.generated }}"
          NEW_TOTAL="${{ steps.generate.outputs.new_total }}"
          TOTAL="${{ steps.check-state.outputs.total }}"

          # Configure git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Stage new RTO files
          git add "data/$STATE/*.json"

          # Commit
          git commit -m "chore: Add $GENERATED RTOs for $STATE ($NEW_TOTAL/$TOTAL)" \
                     -m "Automated RTO data population" \
                     -m "- Generated: $GENERATED new RTOs" \
                     -m "- Progress: $NEW_TOTAL/$TOTAL ($((NEW_TOTAL * 100 / TOTAL))%)" \
                     -m "- State: $STATE"

          # Push directly to main
          git push origin main

          echo "‚úÖ Committed $GENERATED RTOs to main"

      - name: Trigger Post-Merge Processing
        if: steps.determine-state.outputs.state != 'NONE' && steps.check-state.outputs.skip != 'true' && steps.generate.outputs.success == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          STATE="${{ steps.determine-state.outputs.state }}"
          echo "üöÄ Triggering post-merge processing for $STATE"
          gh workflow run post-merge.yml -f state="$STATE" || echo "‚ö†Ô∏è Failed to trigger post-merge workflow"

      - name: Update state rotation cache
        if: steps.determine-state.outputs.state != 'NONE' && steps.check-state.outputs.skip != 'true'
        run: |
          STATE="${{ steps.determine-state.outputs.state }}"

          mkdir -p .github-cache

          # Update rotation data
          printf '{\n  "lastProcessedState": "%s",\n  "lastRunTime": "%s"\n}\n' \
            "$STATE" \
            "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            > .github-cache/state-rotation.json

      - name: Save state rotation cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .github-cache/state-rotation.json
          key: state-rotation-${{ github.run_id }}

      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const state = '${{ steps.determine-state.outputs.state }}';
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Automated RTO Population Failed: ${state}`,
              body: `## Automated RTO Population Failed

            **State:** ${state}
            **Workflow Run:** ${runUrl}
            **Triggered by:** ${{ github.event_name }}
            **Time:** ${new Date().toISOString()}

            ### Error Details
            The automated RTO population workflow failed. This could be due to:
            - API rate limits exceeded
            - Invalid data format
            - Network issues
            - Missing environment variables

            ### Action Required
            Please review the workflow logs and retry manually if needed.

            ---
            *This issue was automatically created by the scheduled RTO population workflow.*`,
              labels: ['automated', 'bug', 'data']
            });

      - name: Summary
        if: always()
        run: |
          echo "=========================================="
          echo "Scheduled RTO Population Summary"
          echo "=========================================="
          echo ""
          echo "State: ${{ steps.determine-state.outputs.state }}"
          echo "Generated: ${{ steps.generate.outputs.generated || 0 }} RTOs"
          echo ""
          echo "‚úÖ Changes pushed directly to main"
          echo "‚úÖ Post-merge workflow will generate images"
          echo "=========================================="
